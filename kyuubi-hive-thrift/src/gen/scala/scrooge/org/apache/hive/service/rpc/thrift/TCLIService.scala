/**
 * Generated by Scrooge
 *   version: 19.12.0
 *   rev: dfdb68cf6b9c501dbbe3ae644504bf403ad76bfa
 *   built at: 20191212-171820
 */
package org.apache.hive.service.rpc.thrift

import com.twitter.scrooge._
import org.apache.thrift.protocol._
import scala.collection.mutable.Builder
import scala.collection.immutable.{Map => immutable$Map, Set => immutable$Set}
import scala.language.higherKinds
import scala.reflect.{ClassTag, classTag}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
trait TCLIService[+MM[_]] extends _root_.com.twitter.finagle.thrift.ThriftService {
  
  def openSession(req: org.apache.hive.service.rpc.thrift.TOpenSessionReq): MM[org.apache.hive.service.rpc.thrift.TOpenSessionResp]
  
  def closeSession(req: org.apache.hive.service.rpc.thrift.TCloseSessionReq): MM[org.apache.hive.service.rpc.thrift.TCloseSessionResp]
  
  def getInfo(req: org.apache.hive.service.rpc.thrift.TGetInfoReq): MM[org.apache.hive.service.rpc.thrift.TGetInfoResp]
  
  def executeStatement(req: org.apache.hive.service.rpc.thrift.TExecuteStatementReq): MM[org.apache.hive.service.rpc.thrift.TExecuteStatementResp]
  
  def getTypeInfo(req: org.apache.hive.service.rpc.thrift.TGetTypeInfoReq): MM[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp]
  
  def getCatalogs(req: org.apache.hive.service.rpc.thrift.TGetCatalogsReq): MM[org.apache.hive.service.rpc.thrift.TGetCatalogsResp]
  
  def getSchemas(req: org.apache.hive.service.rpc.thrift.TGetSchemasReq): MM[org.apache.hive.service.rpc.thrift.TGetSchemasResp]
  
  def getTables(req: org.apache.hive.service.rpc.thrift.TGetTablesReq): MM[org.apache.hive.service.rpc.thrift.TGetTablesResp]
  
  def getTableTypes(req: org.apache.hive.service.rpc.thrift.TGetTableTypesReq): MM[org.apache.hive.service.rpc.thrift.TGetTableTypesResp]
  
  def getColumns(req: org.apache.hive.service.rpc.thrift.TGetColumnsReq): MM[org.apache.hive.service.rpc.thrift.TGetColumnsResp]
  
  def getFunctions(req: org.apache.hive.service.rpc.thrift.TGetFunctionsReq): MM[org.apache.hive.service.rpc.thrift.TGetFunctionsResp]
  
  def getPrimaryKeys(req: org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq): MM[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp]
  
  def getCrossReference(req: org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq): MM[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp]
  
  def getOperationStatus(req: org.apache.hive.service.rpc.thrift.TGetOperationStatusReq): MM[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp]
  
  def cancelOperation(req: org.apache.hive.service.rpc.thrift.TCancelOperationReq): MM[org.apache.hive.service.rpc.thrift.TCancelOperationResp]
  
  def closeOperation(req: org.apache.hive.service.rpc.thrift.TCloseOperationReq): MM[org.apache.hive.service.rpc.thrift.TCloseOperationResp]
  
  def getResultSetMetadata(req: org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq): MM[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp]
  
  def fetchResults(req: org.apache.hive.service.rpc.thrift.TFetchResultsReq): MM[org.apache.hive.service.rpc.thrift.TFetchResultsResp]
  
  def getDelegationToken(req: org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq): MM[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp]
  
  def cancelDelegationToken(req: org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq): MM[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp]
  
  def renewDelegationToken(req: org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq): MM[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp]
  
  def getQueryId(req: org.apache.hive.service.rpc.thrift.TGetQueryIdReq): MM[org.apache.hive.service.rpc.thrift.TGetQueryIdResp]
  
  def setClientInfo(req: org.apache.hive.service.rpc.thrift.TSetClientInfoReq): MM[org.apache.hive.service.rpc.thrift.TSetClientInfoResp]

  /**
   * Used to close the underlying `Service`.
   * Not a user-defined API.
   */
  def asClosable: _root_.com.twitter.util.Closable = _root_.com.twitter.util.Closable.nop
}


object TCLIService { self =>

  val annotations: immutable$Map[String, String] = immutable$Map.empty

  val methods: immutable$Set[ThriftMethod] = immutable$Set(
    self.OpenSession,
    self.CloseSession,
    self.GetInfo,
    self.ExecuteStatement,
    self.GetTypeInfo,
    self.GetCatalogs,
    self.GetSchemas,
    self.GetTables,
    self.GetTableTypes,
    self.GetColumns,
    self.GetFunctions,
    self.GetPrimaryKeys,
    self.GetCrossReference,
    self.GetOperationStatus,
    self.CancelOperation,
    self.CloseOperation,
    self.GetResultSetMetadata,
    self.FetchResults,
    self.GetDelegationToken,
    self.CancelDelegationToken,
    self.RenewDelegationToken,
    self.GetQueryId,
    self.SetClientInfo
  )

  object OpenSession extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("openSession_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TOpenSessionReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TOpenSessionReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TOpenSessionReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TOpenSessionReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TOpenSessionReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TOpenSessionReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TOpenSessionReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TOpenSessionReq = {
        org.apache.hive.service.rpc.thrift.TOpenSessionReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TOpenSessionReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TOpenSessionReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TOpenSessionReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TOpenSessionReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TOpenSessionReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TOpenSessionReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TOpenSessionReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TOpenSessionReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TOpenSessionReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TOpenSessionResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("openSession_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TOpenSessionResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TOpenSessionResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TOpenSessionResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TOpenSessionResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TOpenSessionResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TOpenSessionResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TOpenSessionResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TOpenSessionResp = {
        org.apache.hive.service.rpc.thrift.TOpenSessionResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TOpenSessionResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TOpenSessionResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TOpenSessionResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TOpenSessionResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TOpenSessionResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TOpenSessionResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TOpenSessionResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TOpenSessionResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TOpenSessionResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TOpenSessionResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TOpenSessionResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "OpenSession"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val openSession$args: OpenSession.Args.type = OpenSession.Args
  type openSession$args = OpenSession.Args

  val openSession$result: OpenSession.Result.type = OpenSession.Result
  type openSession$result = OpenSession.Result

  object CloseSession extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("closeSession_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TCloseSessionReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TCloseSessionReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TCloseSessionReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TCloseSessionReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TCloseSessionReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TCloseSessionReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseSessionReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TCloseSessionReq = {
        org.apache.hive.service.rpc.thrift.TCloseSessionReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TCloseSessionReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TCloseSessionReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TCloseSessionReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TCloseSessionReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TCloseSessionReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TCloseSessionReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TCloseSessionReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TCloseSessionReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TCloseSessionReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TCloseSessionResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("closeSession_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TCloseSessionResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TCloseSessionResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseSessionResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TCloseSessionResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseSessionResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseSessionResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseSessionResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TCloseSessionResp = {
        org.apache.hive.service.rpc.thrift.TCloseSessionResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TCloseSessionResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TCloseSessionResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseSessionResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TCloseSessionResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TCloseSessionResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseSessionResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseSessionResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TCloseSessionResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseSessionResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseSessionResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseSessionResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "CloseSession"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val closeSession$args: CloseSession.Args.type = CloseSession.Args
  type closeSession$args = CloseSession.Args

  val closeSession$result: CloseSession.Result.type = CloseSession.Result
  type closeSession$result = CloseSession.Result

  object GetInfo extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getInfo_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetInfoReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetInfoReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TGetInfoReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TGetInfoReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TGetInfoReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TGetInfoReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetInfoReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetInfoReq = {
        org.apache.hive.service.rpc.thrift.TGetInfoReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TGetInfoReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TGetInfoReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TGetInfoReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TGetInfoReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TGetInfoReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TGetInfoReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TGetInfoReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetInfoReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetInfoReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TGetInfoResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getInfo_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetInfoResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetInfoResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetInfoResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TGetInfoResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetInfoResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetInfoResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetInfoResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetInfoResp = {
        org.apache.hive.service.rpc.thrift.TGetInfoResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TGetInfoResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TGetInfoResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetInfoResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TGetInfoResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TGetInfoResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetInfoResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetInfoResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TGetInfoResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetInfoResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetInfoResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetInfoResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "GetInfo"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getInfo$args: GetInfo.Args.type = GetInfo.Args
  type getInfo$args = GetInfo.Args

  val getInfo$result: GetInfo.Result.type = GetInfo.Result
  type getInfo$result = GetInfo.Result

  object ExecuteStatement extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("executeStatement_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TExecuteStatementReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TExecuteStatementReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TExecuteStatementReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TExecuteStatementReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TExecuteStatementReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TExecuteStatementReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TExecuteStatementReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TExecuteStatementReq = {
        org.apache.hive.service.rpc.thrift.TExecuteStatementReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TExecuteStatementReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TExecuteStatementReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TExecuteStatementReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TExecuteStatementReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TExecuteStatementReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TExecuteStatementReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TExecuteStatementReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TExecuteStatementReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TExecuteStatementReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TExecuteStatementResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("executeStatement_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TExecuteStatementResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TExecuteStatementResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TExecuteStatementResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TExecuteStatementResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TExecuteStatementResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TExecuteStatementResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TExecuteStatementResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TExecuteStatementResp = {
        org.apache.hive.service.rpc.thrift.TExecuteStatementResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TExecuteStatementResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TExecuteStatementResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TExecuteStatementResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TExecuteStatementResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TExecuteStatementResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TExecuteStatementResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TExecuteStatementResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TExecuteStatementResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TExecuteStatementResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TExecuteStatementResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TExecuteStatementResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "ExecuteStatement"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val executeStatement$args: ExecuteStatement.Args.type = ExecuteStatement.Args
  type executeStatement$args = ExecuteStatement.Args

  val executeStatement$result: ExecuteStatement.Result.type = ExecuteStatement.Result
  type executeStatement$result = ExecuteStatement.Result

  object GetTypeInfo extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getTypeInfo_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetTypeInfoReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetTypeInfoReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TGetTypeInfoReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TGetTypeInfoReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TGetTypeInfoReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TGetTypeInfoReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTypeInfoReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetTypeInfoReq = {
        org.apache.hive.service.rpc.thrift.TGetTypeInfoReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TGetTypeInfoReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TGetTypeInfoReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TGetTypeInfoReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TGetTypeInfoReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TGetTypeInfoReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TGetTypeInfoReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TGetTypeInfoReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetTypeInfoReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetTypeInfoReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TGetTypeInfoResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getTypeInfo_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TGetTypeInfoResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetTypeInfoResp = {
        org.apache.hive.service.rpc.thrift.TGetTypeInfoResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TGetTypeInfoResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TGetTypeInfoResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTypeInfoResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "GetTypeInfo"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getTypeInfo$args: GetTypeInfo.Args.type = GetTypeInfo.Args
  type getTypeInfo$args = GetTypeInfo.Args

  val getTypeInfo$result: GetTypeInfo.Result.type = GetTypeInfo.Result
  type getTypeInfo$result = GetTypeInfo.Result

  object GetCatalogs extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getCatalogs_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetCatalogsReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetCatalogsReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TGetCatalogsReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TGetCatalogsReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TGetCatalogsReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TGetCatalogsReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCatalogsReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetCatalogsReq = {
        org.apache.hive.service.rpc.thrift.TGetCatalogsReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TGetCatalogsReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TGetCatalogsReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TGetCatalogsReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TGetCatalogsReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TGetCatalogsReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TGetCatalogsReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TGetCatalogsReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetCatalogsReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetCatalogsReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TGetCatalogsResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getCatalogs_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetCatalogsResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetCatalogsResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCatalogsResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TGetCatalogsResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCatalogsResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCatalogsResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCatalogsResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetCatalogsResp = {
        org.apache.hive.service.rpc.thrift.TGetCatalogsResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TGetCatalogsResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TGetCatalogsResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCatalogsResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TGetCatalogsResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TGetCatalogsResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCatalogsResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCatalogsResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TGetCatalogsResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCatalogsResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCatalogsResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCatalogsResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "GetCatalogs"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getCatalogs$args: GetCatalogs.Args.type = GetCatalogs.Args
  type getCatalogs$args = GetCatalogs.Args

  val getCatalogs$result: GetCatalogs.Result.type = GetCatalogs.Result
  type getCatalogs$result = GetCatalogs.Result

  object GetSchemas extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getSchemas_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetSchemasReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetSchemasReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TGetSchemasReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TGetSchemasReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TGetSchemasReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TGetSchemasReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetSchemasReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetSchemasReq = {
        org.apache.hive.service.rpc.thrift.TGetSchemasReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TGetSchemasReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TGetSchemasReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TGetSchemasReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TGetSchemasReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TGetSchemasReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TGetSchemasReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TGetSchemasReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetSchemasReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetSchemasReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TGetSchemasResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getSchemas_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetSchemasResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetSchemasResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetSchemasResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TGetSchemasResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetSchemasResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetSchemasResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetSchemasResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetSchemasResp = {
        org.apache.hive.service.rpc.thrift.TGetSchemasResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TGetSchemasResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TGetSchemasResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetSchemasResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TGetSchemasResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TGetSchemasResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetSchemasResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetSchemasResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TGetSchemasResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetSchemasResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetSchemasResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetSchemasResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "GetSchemas"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getSchemas$args: GetSchemas.Args.type = GetSchemas.Args
  type getSchemas$args = GetSchemas.Args

  val getSchemas$result: GetSchemas.Result.type = GetSchemas.Result
  type getSchemas$result = GetSchemas.Result

  object GetTables extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getTables_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetTablesReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetTablesReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TGetTablesReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TGetTablesReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TGetTablesReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TGetTablesReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTablesReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetTablesReq = {
        org.apache.hive.service.rpc.thrift.TGetTablesReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TGetTablesReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TGetTablesReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TGetTablesReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TGetTablesReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TGetTablesReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TGetTablesReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TGetTablesReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetTablesReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetTablesReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TGetTablesResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getTables_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetTablesResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetTablesResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTablesResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TGetTablesResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTablesResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTablesResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTablesResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetTablesResp = {
        org.apache.hive.service.rpc.thrift.TGetTablesResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TGetTablesResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TGetTablesResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTablesResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TGetTablesResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TGetTablesResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTablesResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTablesResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TGetTablesResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTablesResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTablesResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTablesResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "GetTables"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getTables$args: GetTables.Args.type = GetTables.Args
  type getTables$args = GetTables.Args

  val getTables$result: GetTables.Result.type = GetTables.Result
  type getTables$result = GetTables.Result

  object GetTableTypes extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getTableTypes_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetTableTypesReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetTableTypesReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TGetTableTypesReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TGetTableTypesReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TGetTableTypesReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TGetTableTypesReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTableTypesReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetTableTypesReq = {
        org.apache.hive.service.rpc.thrift.TGetTableTypesReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TGetTableTypesReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TGetTableTypesReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TGetTableTypesReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TGetTableTypesReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TGetTableTypesReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TGetTableTypesReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TGetTableTypesReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetTableTypesReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetTableTypesReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TGetTableTypesResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getTableTypes_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetTableTypesResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetTableTypesResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTableTypesResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TGetTableTypesResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTableTypesResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTableTypesResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTableTypesResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetTableTypesResp = {
        org.apache.hive.service.rpc.thrift.TGetTableTypesResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TGetTableTypesResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TGetTableTypesResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTableTypesResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TGetTableTypesResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TGetTableTypesResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTableTypesResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTableTypesResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TGetTableTypesResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTableTypesResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTableTypesResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetTableTypesResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "GetTableTypes"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getTableTypes$args: GetTableTypes.Args.type = GetTableTypes.Args
  type getTableTypes$args = GetTableTypes.Args

  val getTableTypes$result: GetTableTypes.Result.type = GetTableTypes.Result
  type getTableTypes$result = GetTableTypes.Result

  object GetColumns extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getColumns_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetColumnsReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetColumnsReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TGetColumnsReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TGetColumnsReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TGetColumnsReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TGetColumnsReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetColumnsReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetColumnsReq = {
        org.apache.hive.service.rpc.thrift.TGetColumnsReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TGetColumnsReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TGetColumnsReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TGetColumnsReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TGetColumnsReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TGetColumnsReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TGetColumnsReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TGetColumnsReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetColumnsReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetColumnsReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TGetColumnsResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getColumns_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetColumnsResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetColumnsResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetColumnsResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TGetColumnsResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetColumnsResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetColumnsResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetColumnsResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetColumnsResp = {
        org.apache.hive.service.rpc.thrift.TGetColumnsResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TGetColumnsResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TGetColumnsResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetColumnsResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TGetColumnsResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TGetColumnsResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetColumnsResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetColumnsResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TGetColumnsResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetColumnsResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetColumnsResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetColumnsResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "GetColumns"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getColumns$args: GetColumns.Args.type = GetColumns.Args
  type getColumns$args = GetColumns.Args

  val getColumns$result: GetColumns.Result.type = GetColumns.Result
  type getColumns$result = GetColumns.Result

  object GetFunctions extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getFunctions_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetFunctionsReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetFunctionsReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TGetFunctionsReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TGetFunctionsReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TGetFunctionsReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TGetFunctionsReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetFunctionsReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetFunctionsReq = {
        org.apache.hive.service.rpc.thrift.TGetFunctionsReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TGetFunctionsReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TGetFunctionsReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TGetFunctionsReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TGetFunctionsReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TGetFunctionsReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TGetFunctionsReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TGetFunctionsReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetFunctionsReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetFunctionsReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TGetFunctionsResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getFunctions_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetFunctionsResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetFunctionsResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetFunctionsResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TGetFunctionsResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetFunctionsResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetFunctionsResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetFunctionsResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetFunctionsResp = {
        org.apache.hive.service.rpc.thrift.TGetFunctionsResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TGetFunctionsResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TGetFunctionsResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetFunctionsResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TGetFunctionsResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TGetFunctionsResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetFunctionsResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetFunctionsResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TGetFunctionsResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetFunctionsResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetFunctionsResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetFunctionsResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "GetFunctions"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getFunctions$args: GetFunctions.Args.type = GetFunctions.Args
  type getFunctions$args = GetFunctions.Args

  val getFunctions$result: GetFunctions.Result.type = GetFunctions.Result
  type getFunctions$result = GetFunctions.Result

  object GetPrimaryKeys extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getPrimaryKeys_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq = {
        org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getPrimaryKeys_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp = {
        org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetPrimaryKeysResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "GetPrimaryKeys"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getPrimaryKeys$args: GetPrimaryKeys.Args.type = GetPrimaryKeys.Args
  type getPrimaryKeys$args = GetPrimaryKeys.Args

  val getPrimaryKeys$result: GetPrimaryKeys.Result.type = GetPrimaryKeys.Result
  type getPrimaryKeys$result = GetPrimaryKeys.Result

  object GetCrossReference extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getCrossReference_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq = {
        org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetCrossReferenceReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getCrossReference_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp = {
        org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetCrossReferenceResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "GetCrossReference"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getCrossReference$args: GetCrossReference.Args.type = GetCrossReference.Args
  type getCrossReference$args = GetCrossReference.Args

  val getCrossReference$result: GetCrossReference.Result.type = GetCrossReference.Result
  type getCrossReference$result = GetCrossReference.Result

  object GetOperationStatus extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getOperationStatus_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetOperationStatusReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetOperationStatusReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TGetOperationStatusReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TGetOperationStatusReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TGetOperationStatusReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TGetOperationStatusReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetOperationStatusReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetOperationStatusReq = {
        org.apache.hive.service.rpc.thrift.TGetOperationStatusReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TGetOperationStatusReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TGetOperationStatusReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TGetOperationStatusReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TGetOperationStatusReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TGetOperationStatusReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TGetOperationStatusReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TGetOperationStatusReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetOperationStatusReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetOperationStatusReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TGetOperationStatusResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getOperationStatus_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TGetOperationStatusResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetOperationStatusResp = {
        org.apache.hive.service.rpc.thrift.TGetOperationStatusResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TGetOperationStatusResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TGetOperationStatusResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetOperationStatusResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "GetOperationStatus"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getOperationStatus$args: GetOperationStatus.Args.type = GetOperationStatus.Args
  type getOperationStatus$args = GetOperationStatus.Args

  val getOperationStatus$result: GetOperationStatus.Result.type = GetOperationStatus.Result
  type getOperationStatus$result = GetOperationStatus.Result

  object CancelOperation extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("cancelOperation_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TCancelOperationReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TCancelOperationReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TCancelOperationReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TCancelOperationReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TCancelOperationReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TCancelOperationReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelOperationReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TCancelOperationReq = {
        org.apache.hive.service.rpc.thrift.TCancelOperationReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TCancelOperationReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TCancelOperationReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TCancelOperationReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TCancelOperationReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TCancelOperationReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TCancelOperationReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TCancelOperationReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TCancelOperationReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TCancelOperationReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TCancelOperationResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("cancelOperation_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TCancelOperationResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TCancelOperationResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelOperationResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TCancelOperationResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelOperationResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelOperationResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelOperationResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TCancelOperationResp = {
        org.apache.hive.service.rpc.thrift.TCancelOperationResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TCancelOperationResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TCancelOperationResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelOperationResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TCancelOperationResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TCancelOperationResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelOperationResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelOperationResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TCancelOperationResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelOperationResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelOperationResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelOperationResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "CancelOperation"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val cancelOperation$args: CancelOperation.Args.type = CancelOperation.Args
  type cancelOperation$args = CancelOperation.Args

  val cancelOperation$result: CancelOperation.Result.type = CancelOperation.Result
  type cancelOperation$result = CancelOperation.Result

  object CloseOperation extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("closeOperation_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TCloseOperationReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TCloseOperationReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TCloseOperationReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TCloseOperationReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TCloseOperationReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TCloseOperationReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseOperationReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TCloseOperationReq = {
        org.apache.hive.service.rpc.thrift.TCloseOperationReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TCloseOperationReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TCloseOperationReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TCloseOperationReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TCloseOperationReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TCloseOperationReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TCloseOperationReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TCloseOperationReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TCloseOperationReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TCloseOperationReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TCloseOperationResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("closeOperation_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TCloseOperationResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TCloseOperationResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseOperationResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TCloseOperationResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseOperationResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseOperationResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseOperationResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TCloseOperationResp = {
        org.apache.hive.service.rpc.thrift.TCloseOperationResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TCloseOperationResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TCloseOperationResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseOperationResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TCloseOperationResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TCloseOperationResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseOperationResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseOperationResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TCloseOperationResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseOperationResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseOperationResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCloseOperationResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "CloseOperation"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val closeOperation$args: CloseOperation.Args.type = CloseOperation.Args
  type closeOperation$args = CloseOperation.Args

  val closeOperation$result: CloseOperation.Result.type = CloseOperation.Result
  type closeOperation$result = CloseOperation.Result

  object GetResultSetMetadata extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getResultSetMetadata_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq = {
        org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getResultSetMetadata_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp = {
        org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetResultSetMetadataResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "GetResultSetMetadata"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getResultSetMetadata$args: GetResultSetMetadata.Args.type = GetResultSetMetadata.Args
  type getResultSetMetadata$args = GetResultSetMetadata.Args

  val getResultSetMetadata$result: GetResultSetMetadata.Result.type = GetResultSetMetadata.Result
  type getResultSetMetadata$result = GetResultSetMetadata.Result

  object FetchResults extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("fetchResults_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TFetchResultsReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TFetchResultsReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TFetchResultsReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TFetchResultsReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TFetchResultsReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TFetchResultsReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TFetchResultsReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TFetchResultsReq = {
        org.apache.hive.service.rpc.thrift.TFetchResultsReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TFetchResultsReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TFetchResultsReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TFetchResultsReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TFetchResultsReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TFetchResultsReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TFetchResultsReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TFetchResultsReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TFetchResultsReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TFetchResultsReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TFetchResultsResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("fetchResults_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TFetchResultsResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TFetchResultsResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TFetchResultsResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TFetchResultsResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TFetchResultsResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TFetchResultsResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TFetchResultsResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TFetchResultsResp = {
        org.apache.hive.service.rpc.thrift.TFetchResultsResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TFetchResultsResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TFetchResultsResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TFetchResultsResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TFetchResultsResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TFetchResultsResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TFetchResultsResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TFetchResultsResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TFetchResultsResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TFetchResultsResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TFetchResultsResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TFetchResultsResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "FetchResults"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val fetchResults$args: FetchResults.Args.type = FetchResults.Args
  type fetchResults$args = FetchResults.Args

  val fetchResults$result: FetchResults.Result.type = FetchResults.Result
  type fetchResults$result = FetchResults.Result

  object GetDelegationToken extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getDelegationToken_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq = {
        org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetDelegationTokenReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getDelegationToken_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp = {
        org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetDelegationTokenResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "GetDelegationToken"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getDelegationToken$args: GetDelegationToken.Args.type = GetDelegationToken.Args
  type getDelegationToken$args = GetDelegationToken.Args

  val getDelegationToken$result: GetDelegationToken.Result.type = GetDelegationToken.Result
  type getDelegationToken$result = GetDelegationToken.Result

  object CancelDelegationToken extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("cancelDelegationToken_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq = {
        org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("cancelDelegationToken_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp = {
        org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TCancelDelegationTokenResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "CancelDelegationToken"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val cancelDelegationToken$args: CancelDelegationToken.Args.type = CancelDelegationToken.Args
  type cancelDelegationToken$args = CancelDelegationToken.Args

  val cancelDelegationToken$result: CancelDelegationToken.Result.type = CancelDelegationToken.Result
  type cancelDelegationToken$result = CancelDelegationToken.Result

  object RenewDelegationToken extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("renewDelegationToken_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq = {
        org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("renewDelegationToken_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp = {
        org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TRenewDelegationTokenResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "RenewDelegationToken"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val renewDelegationToken$args: RenewDelegationToken.Args.type = RenewDelegationToken.Args
  type renewDelegationToken$args = RenewDelegationToken.Args

  val renewDelegationToken$result: RenewDelegationToken.Result.type = RenewDelegationToken.Result
  type renewDelegationToken$result = RenewDelegationToken.Result

  object GetQueryId extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getQueryId_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetQueryIdReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetQueryIdReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TGetQueryIdReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TGetQueryIdReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TGetQueryIdReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TGetQueryIdReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetQueryIdReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetQueryIdReq = {
        org.apache.hive.service.rpc.thrift.TGetQueryIdReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TGetQueryIdReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TGetQueryIdReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TGetQueryIdReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TGetQueryIdReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TGetQueryIdReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TGetQueryIdReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TGetQueryIdReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetQueryIdReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TGetQueryIdReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TGetQueryIdResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("getQueryId_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TGetQueryIdResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TGetQueryIdResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetQueryIdResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TGetQueryIdResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetQueryIdResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetQueryIdResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetQueryIdResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TGetQueryIdResp = {
        org.apache.hive.service.rpc.thrift.TGetQueryIdResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TGetQueryIdResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TGetQueryIdResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetQueryIdResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TGetQueryIdResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TGetQueryIdResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetQueryIdResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetQueryIdResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TGetQueryIdResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetQueryIdResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetQueryIdResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TGetQueryIdResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "GetQueryId"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val getQueryId$args: GetQueryId.Args.type = GetQueryId.Args
  type getQueryId$args = GetQueryId.Args

  val getQueryId$result: GetQueryId.Result.type = GetQueryId.Result
  type getQueryId$result = GetQueryId.Result

  object SetClientInfo extends ThriftMethod {
    
    object Args extends ValidatingThriftStructCodec3[Args] with StructBuilderFactory[Args] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("setClientInfo_args")
      val ReqField: TField = new TField("req", TType.STRUCT, 1)
      val ReqFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TSetClientInfoReq] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TSetClientInfoReq]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          ReqField,
          false,
          false,
          ReqFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[org.apache.hive.service.rpc.thrift.TSetClientInfoReq].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Args]] = {
        Seq(
          new ThriftStructField[Args](
            ReqField,
            _root_.scala.Some(ReqFieldManifest),
            classOf[Args]) {
              def getValue[R](struct: Args): R = struct.req.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Args] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Args): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Args): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.req)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Args): Args =
        new Args(
          req =
            {
              val field = original.req
              org.apache.hive.service.rpc.thrift.TSetClientInfoReq.withoutPassthroughFields(field)
            }
        )
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Args, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Args = {
        var req: org.apache.hive.service.rpc.thrift.TSetClientInfoReq = null
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 1 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    req = readReqValue(_iprot)
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'req' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Args(
          req,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        req: org.apache.hive.service.rpc.thrift.TSetClientInfoReq
      ): Args =
        new Args(
          req
        )
    
      def unapply(_item: Args): _root_.scala.Option[org.apache.hive.service.rpc.thrift.TSetClientInfoReq] = _root_.scala.Some(_item.req)
    
    
      @inline private[thrift] def readReqValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TSetClientInfoReq = {
        org.apache.hive.service.rpc.thrift.TSetClientInfoReq.decode(_iprot)
      }
    
      @inline private def writeReqField(req_item: org.apache.hive.service.rpc.thrift.TSetClientInfoReq, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(ReqField)
        writeReqValue(req_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeReqValue(req_item: org.apache.hive.service.rpc.thrift.TSetClientInfoReq, _oprot: TProtocol): Unit = {
        req_item.write(_oprot)
      }
    
    
    }
    
    class Args(
        val req: org.apache.hive.service.rpc.thrift.TSetClientInfoReq,
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftStruct
      with _root_.scala.Product1[org.apache.hive.service.rpc.thrift.TSetClientInfoReq]
      with ValidatingThriftStruct[Args]
      with java.io.Serializable
    {
      import Args._
    
      def this(
        req: org.apache.hive.service.rpc.thrift.TSetClientInfoReq
      ) = this(
        req,
        immutable$Map.empty
      )
    
      def _1: org.apache.hive.service.rpc.thrift.TSetClientInfoReq = req
    
    
    
      override def write(_oprot: TProtocol): Unit = {
        Args.validate(this)
        _oprot.writeStructBegin(Struct)
        if (req ne null) writeReqField(req, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        req: org.apache.hive.service.rpc.thrift.TSetClientInfoReq = this.req,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Args =
        new Args(
          req,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Args]
    
      private def _equals(x: Args, y: Args): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Args])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.req
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Args"
    
      def _codec: ValidatingThriftStructCodec3[Args] = Args
    
      def newBuilder(): StructBuilder[Args] = new ArgsStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ArgsStructBuilder(instance: _root_.scala.Option[Args], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Args](fieldTypes) {
    
      def build(): Args = instance match {
        case _root_.scala.Some(i) =>
          Args(
            (if (fieldArray(0) == null) i.req else fieldArray(0)).asInstanceOf[org.apache.hive.service.rpc.thrift.TSetClientInfoReq]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Args"))
          else {
            Args(
              fieldArray(0).asInstanceOf[org.apache.hive.service.rpc.thrift.TSetClientInfoReq]
            )
          }
        }
    }

    type SuccessType = org.apache.hive.service.rpc.thrift.TSetClientInfoResp
    
    object Result extends ValidatingThriftStructCodec3[Result] with StructBuilderFactory[Result] {
      val NoPassthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty[Short, TFieldBlob]
      val Struct: TStruct = new TStruct("setClientInfo_result")
      val SuccessField: TField = new TField("success", TType.STRUCT, 0)
      val SuccessFieldManifest: Manifest[org.apache.hive.service.rpc.thrift.TSetClientInfoResp] = implicitly[Manifest[org.apache.hive.service.rpc.thrift.TSetClientInfoResp]]
    
      /**
       * Field information in declaration order.
       */
      lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
        new ThriftStructFieldInfo(
          SuccessField,
          true,
          false,
          SuccessFieldManifest,
          _root_.scala.None,
          _root_.scala.None,
          immutable$Map.empty[String, String],
          immutable$Map.empty[String, String],
          None
        )
      )
    
      lazy val structAnnotations: immutable$Map[String, String] =
        immutable$Map.empty[String, String]
    
      private val fieldTypes: IndexedSeq[ClassTag[_]] = IndexedSeq(
        classTag[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TSetClientInfoResp]].asInstanceOf[ClassTag[_]]
      )
    
      private[this] val structFields: Seq[ThriftStructField[Result]] = {
        Seq(
          new ThriftStructField[Result](
            SuccessField,
            _root_.scala.Some(SuccessFieldManifest),
            classOf[Result]) {
              def getValue[R](struct: Result): R = struct.success.asInstanceOf[R]
          }
        )
      }
    
      override lazy val metaData: ThriftStructMetaData[Result] =
        new ThriftStructMetaData(this, structFields, fieldInfos, Seq(), structAnnotations)
    
      /**
       * Checks that all required fields are non-null.
       */
      def validate(_item: Result): Unit = {
      }
    
      /**
       * Checks that the struct is a valid as a new instance. If there are any missing required or
       * construction required fields, return a non-empty list.
       */
      def validateNewInstance(item: Result): scala.Seq[com.twitter.scrooge.validation.Issue] = {
        val buf = scala.collection.mutable.ListBuffer.empty[com.twitter.scrooge.validation.Issue]
    
        buf ++= validateField(item.success)
        buf.toList
      }
    
      def withoutPassthroughFields(original: Result): Result =
        new Result(
          success =
            {
              val field = original.success
              field.map { field =>
                org.apache.hive.service.rpc.thrift.TSetClientInfoResp.withoutPassthroughFields(field)
              }
            }
        )
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.None, fieldTypes)
    
      override def encode(_item: Result, _oproto: TProtocol): Unit = {
        _item.write(_oproto)
      }
    
    
      override def decode(_iprot: TProtocol): Result = {
        var success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TSetClientInfoResp] = _root_.scala.None
        var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
        var _done = false
    
        _iprot.readStructBegin()
        while (!_done) {
          val _field = _iprot.readFieldBegin()
          if (_field.`type` == TType.STOP) {
            _done = true
          } else {
            _field.id match {
              case 0 =>
                _field.`type` match {
                  case TType.STRUCT =>
                    success = _root_.scala.Some(readSuccessValue(_iprot))
                  case _actualType =>
                    val _expectedType = TType.STRUCT
                    throw new TProtocolException(
                      "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                        ttypeToString(_expectedType),
                        ttypeToString(_actualType)
                      )
                    )
                }
              case _ =>
                if (_passthroughFields == null)
                  _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
                _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
            }
            _iprot.readFieldEnd()
          }
        }
        _iprot.readStructEnd()
    
        new Result(
          success,
          if (_passthroughFields == null)
            NoPassthroughFields
          else
            _passthroughFields.result()
        )
      }
    
      def apply(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TSetClientInfoResp] = _root_.scala.None
      ): Result =
        new Result(
          success
        )
    
      def unapply(_item: Result): _root_.scala.Option[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TSetClientInfoResp]] = _root_.scala.Some(_item.success)
    
    
      @inline private[thrift] def readSuccessValue(_iprot: TProtocol): org.apache.hive.service.rpc.thrift.TSetClientInfoResp = {
        org.apache.hive.service.rpc.thrift.TSetClientInfoResp.decode(_iprot)
      }
    
      @inline private def writeSuccessField(success_item: org.apache.hive.service.rpc.thrift.TSetClientInfoResp, _oprot: TProtocol): Unit = {
        _oprot.writeFieldBegin(SuccessField)
        writeSuccessValue(success_item, _oprot)
        _oprot.writeFieldEnd()
      }
    
      @inline private def writeSuccessValue(success_item: org.apache.hive.service.rpc.thrift.TSetClientInfoResp, _oprot: TProtocol): Unit = {
        success_item.write(_oprot)
      }
    
    
    }
    
    class Result(
        val success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TSetClientInfoResp],
        val _passthroughFields: immutable$Map[Short, TFieldBlob])
      extends ThriftResponse[org.apache.hive.service.rpc.thrift.TSetClientInfoResp] with ThriftStruct
      with _root_.scala.Product1[Option[org.apache.hive.service.rpc.thrift.TSetClientInfoResp]]
      with ValidatingThriftStruct[Result]
      with java.io.Serializable
    {
      import Result._
    
      def this(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TSetClientInfoResp] = _root_.scala.None
      ) = this(
        success,
        immutable$Map.empty
      )
    
      def _1: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TSetClientInfoResp] = success
    
      def successField: Option[org.apache.hive.service.rpc.thrift.TSetClientInfoResp] = success
      def exceptionFields: Iterable[Option[com.twitter.scrooge.ThriftException]] = Nil
    
    
      override def write(_oprot: TProtocol): Unit = {
        Result.validate(this)
        _oprot.writeStructBegin(Struct)
        if (success.isDefined) writeSuccessField(success.get, _oprot)
        if (_passthroughFields.nonEmpty) {
          _passthroughFields.values.foreach { _.write(_oprot) }
        }
        _oprot.writeFieldStop()
        _oprot.writeStructEnd()
      }
    
      def copy(
        success: _root_.scala.Option[org.apache.hive.service.rpc.thrift.TSetClientInfoResp] = this.success,
        _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
      ): Result =
        new Result(
          success,
          _passthroughFields
        )
    
      override def canEqual(other: Any): Boolean = other.isInstanceOf[Result]
    
      private def _equals(x: Result, y: Result): Boolean =
          x.productArity == y.productArity &&
          x.productIterator.sameElements(y.productIterator) &&
          x._passthroughFields == y._passthroughFields
    
      override def equals(other: Any): Boolean =
        canEqual(other) &&
          _equals(this, other.asInstanceOf[Result])
    
      override def hashCode: Int = {
        _root_.scala.runtime.ScalaRunTime._hashCode(this)
      }
    
      override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
    
    
      override def productArity: Int = 1
    
      override def productElement(n: Int): Any = n match {
        case 0 => this.success
        case _ => throw new IndexOutOfBoundsException(n.toString)
      }
    
      override def productPrefix: String = "Result"
    
      def _codec: ValidatingThriftStructCodec3[Result] = Result
    
      def newBuilder(): StructBuilder[Result] = new ResultStructBuilder(_root_.scala.Some(this), fieldTypes)
    }
    
    private[thrift] class ResultStructBuilder(instance: _root_.scala.Option[Result], fieldTypes: IndexedSeq[ClassTag[_]])
        extends StructBuilder[Result](fieldTypes) {
    
      def build(): Result = instance match {
        case _root_.scala.Some(i) =>
          Result(
            (if (fieldArray(0) == null) i.success else fieldArray(0)).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TSetClientInfoResp]]
          )
        case _root_.scala.None =>
          if (fieldArray.contains(null)) throw new InvalidFieldsException(structBuildError("Result"))
          else {
            Result(
              fieldArray(0).asInstanceOf[_root_.scala.Option[org.apache.hive.service.rpc.thrift.TSetClientInfoResp]]
            )
          }
        }
    }

    val annotations: immutable$Map[String, String] = immutable$Map.empty

    type FunctionType = Nothing
    type ReqRepFunctionType = Nothing
    type ServiceType = Nothing
    type ReqRepServiceType = Nothing
    type ServiceIfaceServiceType = Nothing
    type ServicePerEndpointServiceType = Nothing
    type ReqRepServicePerEndpointServiceType = Nothing

    def toServiceIfaceService(f: FunctionType): ServiceIfaceServiceType = ???
    def toServicePerEndpointService(f: FunctionType): ServicePerEndpointServiceType = ???
    def toReqRepServicePerEndpointService(f: ReqRepFunctionType): ReqRepServicePerEndpointServiceType = ???

    val name: String = "SetClientInfo"
    val serviceName: String = "TCLIService"
    val argsCodec: Args.type = Args
    val responseCodec: Result.type = Result
    val oneway: Boolean = false
  }

  // Compatibility aliases.
  val setClientInfo$args: SetClientInfo.Args.type = SetClientInfo.Args
  type setClientInfo$args = SetClientInfo.Args

  val setClientInfo$result: SetClientInfo.Result.type = SetClientInfo.Result
  type setClientInfo$result = SetClientInfo.Result


}
