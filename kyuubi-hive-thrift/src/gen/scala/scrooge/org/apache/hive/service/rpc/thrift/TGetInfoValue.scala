/**
 * Generated by Scrooge
 *   version: 19.12.0
 *   rev: dfdb68cf6b9c501dbbe3ae644504bf403ad76bfa
 *   built at: 20191212-171820
 */
package org.apache.hive.service.rpc.thrift

import com.twitter.scrooge.{
  TFieldBlob,
  ThriftStruct,
  ThriftStructFieldInfo,
  ThriftStructMetaData,
  ThriftUnion,
  ThriftUnionFieldInfo,
  ValidatingThriftStruct,
  ValidatingThriftStructCodec3}
import org.apache.thrift.protocol._
import scala.collection.immutable.{Map => immutable$Map}

@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
sealed trait TGetInfoValue
  extends ThriftUnion
  with ThriftStruct
  with ValidatingThriftStruct[TGetInfoValue] {

  def _codec: ValidatingThriftStructCodec3[TGetInfoValue] = TGetInfoValue
}

private object TGetInfoValueDecoder {
  def apply(_iprot: TProtocol, newUnknown: TFieldBlob => TGetInfoValue): TGetInfoValue = {
    var _result: TGetInfoValue = null
    _iprot.readStructBegin()
    val _field = _iprot.readFieldBegin()
    _field.id match {
      case 1 => // stringValue
        _field.`type` match {
          case TType.STRING =>
            _result = TGetInfoValue.StringValue({
              _iprot.readString()
            })
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      case 2 => // smallIntValue
        _field.`type` match {
          case TType.I16 =>
            _result = TGetInfoValue.SmallIntValue({
              _iprot.readI16()
            })
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      case 3 => // integerBitmask
        _field.`type` match {
          case TType.I32 =>
            _result = TGetInfoValue.IntegerBitmask({
              _iprot.readI32()
            })
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      case 4 => // integerFlag
        _field.`type` match {
          case TType.I32 =>
            _result = TGetInfoValue.IntegerFlag({
              _iprot.readI32()
            })
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      case 5 => // binaryValue
        _field.`type` match {
          case TType.I32 =>
            _result = TGetInfoValue.BinaryValue({
              _iprot.readI32()
            })
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      case 6 => // lenValue
        _field.`type` match {
          case TType.I64 =>
            _result = TGetInfoValue.LenValue({
              _iprot.readI64()
            })
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      case _ =>
        if (_field.`type` != TType.STOP) {
          _result = newUnknown(TFieldBlob.read(_field, _iprot))
        } else {
          TProtocolUtil.skip(_iprot, _field.`type`)
        }
    }
    if (_field.`type` != TType.STOP) {
      _iprot.readFieldEnd()
      var _done = false
      var _moreThanOne = false
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP)
          _done = true
        else {
          _moreThanOne = true
          TProtocolUtil.skip(_iprot, _field.`type`)
          _iprot.readFieldEnd()
        }
      }
      if (_moreThanOne) {
        _iprot.readStructEnd()
        throw new TProtocolException("Cannot read a TUnion with more than one set value!")
      }
    }
    _iprot.readStructEnd()
    if (_result == null)
      throw new TProtocolException("Cannot read a TUnion with no set value!")
    _result
  }
}

object TGetInfoValueAliases {

  type StringValueAlias = String

  def withoutPassthroughFields_StringValue(obj: TGetInfoValue.StringValue): TGetInfoValue.StringValue = {
    val field = obj.stringValue
    TGetInfoValue.StringValue(
      field
    )
  }

  val StringValueKeyTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None

  val StringValueValueTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None

  type SmallIntValueAlias = Short

  def withoutPassthroughFields_SmallIntValue(obj: TGetInfoValue.SmallIntValue): TGetInfoValue.SmallIntValue = {
    val field = obj.smallIntValue
    TGetInfoValue.SmallIntValue(
      field
    )
  }

  val SmallIntValueKeyTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None

  val SmallIntValueValueTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None

  type IntegerBitmaskAlias = Int

  def withoutPassthroughFields_IntegerBitmask(obj: TGetInfoValue.IntegerBitmask): TGetInfoValue.IntegerBitmask = {
    val field = obj.integerBitmask
    TGetInfoValue.IntegerBitmask(
      field
    )
  }

  val IntegerBitmaskKeyTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None

  val IntegerBitmaskValueTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None

  type IntegerFlagAlias = Int

  def withoutPassthroughFields_IntegerFlag(obj: TGetInfoValue.IntegerFlag): TGetInfoValue.IntegerFlag = {
    val field = obj.integerFlag
    TGetInfoValue.IntegerFlag(
      field
    )
  }

  val IntegerFlagKeyTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None

  val IntegerFlagValueTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None

  type BinaryValueAlias = Int

  def withoutPassthroughFields_BinaryValue(obj: TGetInfoValue.BinaryValue): TGetInfoValue.BinaryValue = {
    val field = obj.binaryValue
    TGetInfoValue.BinaryValue(
      field
    )
  }

  val BinaryValueKeyTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None

  val BinaryValueValueTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None

  type LenValueAlias = Long

  def withoutPassthroughFields_LenValue(obj: TGetInfoValue.LenValue): TGetInfoValue.LenValue = {
    val field = obj.lenValue
    TGetInfoValue.LenValue(
      field
    )
  }

  val LenValueKeyTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None

  val LenValueValueTypeManifest: _root_.scala.Option[Manifest[_]] = _root_.scala.None
}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
object TGetInfoValue extends ValidatingThriftStructCodec3[TGetInfoValue] {
  val Union: TStruct = new TStruct("TGetInfoValue")
  val StringValueField: TField = new TField("stringValue", TType.STRING, 1)
  val StringValueFieldManifest: Manifest[StringValue] = implicitly[Manifest[StringValue]]
  val SmallIntValueField: TField = new TField("smallIntValue", TType.I16, 2)
  val SmallIntValueFieldManifest: Manifest[SmallIntValue] = implicitly[Manifest[SmallIntValue]]
  val IntegerBitmaskField: TField = new TField("integerBitmask", TType.I32, 3)
  val IntegerBitmaskFieldManifest: Manifest[IntegerBitmask] = implicitly[Manifest[IntegerBitmask]]
  val IntegerFlagField: TField = new TField("integerFlag", TType.I32, 4)
  val IntegerFlagFieldManifest: Manifest[IntegerFlag] = implicitly[Manifest[IntegerFlag]]
  val BinaryValueField: TField = new TField("binaryValue", TType.I32, 5)
  val BinaryValueFieldManifest: Manifest[BinaryValue] = implicitly[Manifest[BinaryValue]]
  val LenValueField: TField = new TField("lenValue", TType.I64, 6)
  val LenValueFieldManifest: Manifest[LenValue] = implicitly[Manifest[LenValue]]

  lazy val structAnnotations: immutable$Map[java.lang.String, java.lang.String] =
    immutable$Map.empty[java.lang.String, java.lang.String]

  /**
   * Field information in declaration order.
   */
  lazy val fieldInfos: scala.List[ThriftUnionFieldInfo[_ <: TGetInfoValue, _]] = scala.List(
    new ThriftUnionFieldInfo[StringValue, TGetInfoValueAliases.StringValueAlias](
      StringValue.fieldInfo,
      StringValue.unapply
    ),
    new ThriftUnionFieldInfo[SmallIntValue, TGetInfoValueAliases.SmallIntValueAlias](
      SmallIntValue.fieldInfo,
      SmallIntValue.unapply
    ),
    new ThriftUnionFieldInfo[IntegerBitmask, TGetInfoValueAliases.IntegerBitmaskAlias](
      IntegerBitmask.fieldInfo,
      IntegerBitmask.unapply
    ),
    new ThriftUnionFieldInfo[IntegerFlag, TGetInfoValueAliases.IntegerFlagAlias](
      IntegerFlag.fieldInfo,
      IntegerFlag.unapply
    ),
    new ThriftUnionFieldInfo[BinaryValue, TGetInfoValueAliases.BinaryValueAlias](
      BinaryValue.fieldInfo,
      BinaryValue.unapply
    ),
    new ThriftUnionFieldInfo[LenValue, TGetInfoValueAliases.LenValueAlias](
      LenValue.fieldInfo,
      LenValue.unapply
    )
  )

  override lazy val metaData = new ThriftStructMetaData(
    this,
    Seq(),
    Seq(),
    fieldInfos.asInstanceOf[Seq[ThriftUnionFieldInfo[_root_.com.twitter.scrooge.ThriftUnion with _root_.com.twitter.scrooge.ThriftStruct, _]]],
    structAnnotations)

  override def encode(_item: TGetInfoValue, _oprot: TProtocol): Unit =
    _item.write(_oprot)

  override def decode(_iprot: TProtocol): TGetInfoValue =
    TGetInfoValueDecoder(_iprot, UnknownUnionField(_))

  def apply(_iprot: TProtocol): TGetInfoValue = decode(_iprot)

  import TGetInfoValueAliases._

  def withoutPassthroughFields(struct: TGetInfoValue): TGetInfoValue = {
    struct match {
      case obj: StringValue => withoutPassthroughFields_StringValue(obj)
      case obj: SmallIntValue => withoutPassthroughFields_SmallIntValue(obj)
      case obj: IntegerBitmask => withoutPassthroughFields_IntegerBitmask(obj)
      case obj: IntegerFlag => withoutPassthroughFields_IntegerFlag(obj)
      case obj: BinaryValue => withoutPassthroughFields_BinaryValue(obj)
      case obj: LenValue => withoutPassthroughFields_LenValue(obj)
      case unknown: UnknownUnionField => unknown // by definition pass-through
    }
  }

  object StringValue extends (StringValueAlias => StringValue) {
    def withoutPassthroughFields(obj: StringValue): StringValue =
      withoutPassthroughFields_StringValue(obj)

    val fieldInfo: ThriftStructFieldInfo =
      new ThriftStructFieldInfo(
        StringValueField,
        false,
        false,
        manifest[StringValueAlias],
        StringValueKeyTypeManifest,
        StringValueValueTypeManifest,
        immutable$Map.empty[java.lang.String, java.lang.String],
        immutable$Map.empty[java.lang.String, java.lang.String]
      )
  }

  case class StringValue(
      stringValue: StringValueAlias)
    extends TGetInfoValue {

    protected type ContainedType = StringValueAlias

    def containedValue(): ContainedType = stringValue

    def unionStructFieldInfo: _root_.scala.Option[ThriftStructFieldInfo] =
      _root_.scala.Some(StringValue.fieldInfo)

    override def write(_oprot: TProtocol): Unit = {
      if (stringValue == null)
        throw new TProtocolException("Cannot write a TUnion with no set value!")
      _oprot.writeStructBegin(Union)
      if (stringValue ne null) {
        val stringValue_item = stringValue
        _oprot.writeFieldBegin(StringValueField)
        _oprot.writeString(stringValue_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

  object SmallIntValue extends (SmallIntValueAlias => SmallIntValue) {
    def withoutPassthroughFields(obj: SmallIntValue): SmallIntValue =
      withoutPassthroughFields_SmallIntValue(obj)

    val fieldInfo: ThriftStructFieldInfo =
      new ThriftStructFieldInfo(
        SmallIntValueField,
        false,
        false,
        manifest[SmallIntValueAlias],
        SmallIntValueKeyTypeManifest,
        SmallIntValueValueTypeManifest,
        immutable$Map.empty[java.lang.String, java.lang.String],
        immutable$Map.empty[java.lang.String, java.lang.String]
      )
  }

  case class SmallIntValue(
      smallIntValue: SmallIntValueAlias)
    extends TGetInfoValue {

    protected type ContainedType = SmallIntValueAlias

    def containedValue(): ContainedType = smallIntValue

    def unionStructFieldInfo: _root_.scala.Option[ThriftStructFieldInfo] =
      _root_.scala.Some(SmallIntValue.fieldInfo)

    override def write(_oprot: TProtocol): Unit = {
      _oprot.writeStructBegin(Union)
      if (true) {
        val smallIntValue_item = smallIntValue
        _oprot.writeFieldBegin(SmallIntValueField)
        _oprot.writeI16(smallIntValue_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

  object IntegerBitmask extends (IntegerBitmaskAlias => IntegerBitmask) {
    def withoutPassthroughFields(obj: IntegerBitmask): IntegerBitmask =
      withoutPassthroughFields_IntegerBitmask(obj)

    val fieldInfo: ThriftStructFieldInfo =
      new ThriftStructFieldInfo(
        IntegerBitmaskField,
        false,
        false,
        manifest[IntegerBitmaskAlias],
        IntegerBitmaskKeyTypeManifest,
        IntegerBitmaskValueTypeManifest,
        immutable$Map.empty[java.lang.String, java.lang.String],
        immutable$Map.empty[java.lang.String, java.lang.String]
      )
  }

  case class IntegerBitmask(
      integerBitmask: IntegerBitmaskAlias)
    extends TGetInfoValue {

    protected type ContainedType = IntegerBitmaskAlias

    def containedValue(): ContainedType = integerBitmask

    def unionStructFieldInfo: _root_.scala.Option[ThriftStructFieldInfo] =
      _root_.scala.Some(IntegerBitmask.fieldInfo)

    override def write(_oprot: TProtocol): Unit = {
      _oprot.writeStructBegin(Union)
      if (true) {
        val integerBitmask_item = integerBitmask
        _oprot.writeFieldBegin(IntegerBitmaskField)
        _oprot.writeI32(integerBitmask_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

  object IntegerFlag extends (IntegerFlagAlias => IntegerFlag) {
    def withoutPassthroughFields(obj: IntegerFlag): IntegerFlag =
      withoutPassthroughFields_IntegerFlag(obj)

    val fieldInfo: ThriftStructFieldInfo =
      new ThriftStructFieldInfo(
        IntegerFlagField,
        false,
        false,
        manifest[IntegerFlagAlias],
        IntegerFlagKeyTypeManifest,
        IntegerFlagValueTypeManifest,
        immutable$Map.empty[java.lang.String, java.lang.String],
        immutable$Map.empty[java.lang.String, java.lang.String]
      )
  }

  case class IntegerFlag(
      integerFlag: IntegerFlagAlias)
    extends TGetInfoValue {

    protected type ContainedType = IntegerFlagAlias

    def containedValue(): ContainedType = integerFlag

    def unionStructFieldInfo: _root_.scala.Option[ThriftStructFieldInfo] =
      _root_.scala.Some(IntegerFlag.fieldInfo)

    override def write(_oprot: TProtocol): Unit = {
      _oprot.writeStructBegin(Union)
      if (true) {
        val integerFlag_item = integerFlag
        _oprot.writeFieldBegin(IntegerFlagField)
        _oprot.writeI32(integerFlag_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

  object BinaryValue extends (BinaryValueAlias => BinaryValue) {
    def withoutPassthroughFields(obj: BinaryValue): BinaryValue =
      withoutPassthroughFields_BinaryValue(obj)

    val fieldInfo: ThriftStructFieldInfo =
      new ThriftStructFieldInfo(
        BinaryValueField,
        false,
        false,
        manifest[BinaryValueAlias],
        BinaryValueKeyTypeManifest,
        BinaryValueValueTypeManifest,
        immutable$Map.empty[java.lang.String, java.lang.String],
        immutable$Map.empty[java.lang.String, java.lang.String]
      )
  }

  case class BinaryValue(
      binaryValue: BinaryValueAlias)
    extends TGetInfoValue {

    protected type ContainedType = BinaryValueAlias

    def containedValue(): ContainedType = binaryValue

    def unionStructFieldInfo: _root_.scala.Option[ThriftStructFieldInfo] =
      _root_.scala.Some(BinaryValue.fieldInfo)

    override def write(_oprot: TProtocol): Unit = {
      _oprot.writeStructBegin(Union)
      if (true) {
        val binaryValue_item = binaryValue
        _oprot.writeFieldBegin(BinaryValueField)
        _oprot.writeI32(binaryValue_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

  object LenValue extends (LenValueAlias => LenValue) {
    def withoutPassthroughFields(obj: LenValue): LenValue =
      withoutPassthroughFields_LenValue(obj)

    val fieldInfo: ThriftStructFieldInfo =
      new ThriftStructFieldInfo(
        LenValueField,
        false,
        false,
        manifest[LenValueAlias],
        LenValueKeyTypeManifest,
        LenValueValueTypeManifest,
        immutable$Map.empty[java.lang.String, java.lang.String],
        immutable$Map.empty[java.lang.String, java.lang.String]
      )
  }

  case class LenValue(
      lenValue: LenValueAlias)
    extends TGetInfoValue {

    protected type ContainedType = LenValueAlias

    def containedValue(): ContainedType = lenValue

    def unionStructFieldInfo: _root_.scala.Option[ThriftStructFieldInfo] =
      _root_.scala.Some(LenValue.fieldInfo)

    override def write(_oprot: TProtocol): Unit = {
      _oprot.writeStructBegin(Union)
      if (true) {
        val lenValue_item = lenValue
        _oprot.writeFieldBegin(LenValueField)
        _oprot.writeI64(lenValue_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

  case class UnknownUnionField private[TGetInfoValue](
      field: TFieldBlob)
    extends TGetInfoValue {

    protected type ContainedType = Unit

    def containedValue(): ContainedType = ()

    def unionStructFieldInfo: _root_.scala.Option[ThriftStructFieldInfo] = _root_.scala.None

    override def write(_oprot: TProtocol): Unit = {
      _oprot.writeStructBegin(Union)
      field.write(_oprot)
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

 /**
  * Checks that the struct is a valid as a new instance. If there are any missing required or
  * construction required fields, return a non-empty list.
  */
  override def validateNewInstance(
    item: TGetInfoValue
  ): scala.Seq[com.twitter.scrooge.validation.Issue] = {
    validateField(item.containedValue())
  }
}